# (quick checklist)
#######################
# CORS for controlled browser access + proper OPTIONS handling.
# JWT validation (NGINX Plus) â€” choose JWKS URL or static key file.
# API key check via X-API-Key header (simple allow-list).
# Active health checks on upstream, with retries and timeouts.
# Method allow-listing and client_max_body_size.
# Custom 429 JSON response for rate-limit hits.
# Structured (JSON) access logs for easy ingestion into ELK/Grafana.
# Keepalive upstream connections.

# ------ Observability: JSON access logs ------
log_format api_json escape=json
  '{'
    '"time":"$time_iso8601",'
    '"client":"$remote_addr",'
    '"method":"$request_method",'
    '"uri":"$request_uri",'
    '"status":$status,'
    '"bytes_out":$bytes_sent,'
    '"bytes_in":$request_length,'
    '"ref":"$http_referer",'
    '"ua":"$http_user_agent",'
    '"req_id":"$request_id",'
    '"upstream_addr":"$upstream_addr",'
    '"upstream_status":"$upstream_status",'
    '"upstream_rt":"$upstream_response_time"'
  '}';

# ------ Global rate limiting (1 req/sec per client IP) ------
limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s;

# Return 429 instead of 503 on limit and emit JSON body
limit_req_status 429;

# ------ Simple API key validation (X-API-Key header) ------
# Set to 1 only when header matches the expected value.
map $http_x_api_key $api_key_ok {
  default 0;
  "SOMESECRET" 1;   # <-- change this secret
}

# ------ CORS: allow specific origins (edit as needed) ------
map $http_origin $cors_origin {
  default "";
  "~^https?://(localhost(:\d+)?|example\.com)$" $http_origin;  # <-- add your allowed origins
}

# ------ Upstream (K8s NodePort targets) with Plus health checks ------
upstream httpbin_backend {
    zone httpbin_backend 64k;

    # List one or more nodes that expose NodePort 30080
    server 10.1.20.22:30080 max_fails=1 fail_timeout=10s;
    # server 10.1.20.23:30080 max_fails=1 fail_timeout=10s;
    # server 10.1.20.24:30080 max_fails=1 fail_timeout=10s;

    keepalive 32;

    # NGINX Plus active health checks (httpbin returns 200 here)
    health_check uri=/status/200 interval=5s jitter=1s fails=2 passes=1;
}

# ------ (Option A) JWT via remote JWKS (NGINX Plus) ------
# The special location below fetches the JWKS when validating tokens.
# Uncomment these two lines in the server{} block to enable JWT:
#   auth_jwt "crapi"; 
#   auth_jwt_key_request /_jwks;
location = /_jwks {
    proxy_pass https://idp.example.com/.well-known/jwks.json;  # <-- your JWKS URI
    proxy_ssl_server_name on;
}

# ------ (Option B) JWT via static key file ------
# auth_jwt "crapi";
# auth_jwt_key_file /etc/nginx/jwt/jwks.json;  # <-- mount a file with JWKs

server {
    listen 8000;
    status_zone httpbin_zone;

    access_log /var/log/nginx/httpbin_access.log api_json;
    error_log  /var/log/nginx/httpbin_error.log;

    # Basic hardening & limits
    client_max_body_size 1m;

    # Upstream timeouts & retries
    proxy_connect_timeout   3s;
    proxy_send_timeout     30s;
    proxy_read_timeout     30s;
    send_timeout           30s;

    proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
    proxy_next_upstream_tries 2;

    # Health endpoint (no auth/rate-limit)
    location = /healthz {
        add_header Content-Type application/json;
        return 200 '{"status":"ok"}';
    }

    # Preflight CORS
    location / {
        # --- Rate limit (1 r/s), burst allows 1 queued request, no delay beyond that
        limit_req zone=perip burst=1 nodelay;

        # --- CORS (only add headers if origin is allowed)
        if ($cors_origin != "") {
            add_header 'Access-Control-Allow-Origin' "$cors_origin" always;
            add_header 'Vary' 'Origin' always;
            add_header 'Access-Control-Allow-Methods' 'GET,POST,PUT,PATCH,DELETE,OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,X-API-Key' always;
            add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Type' always;
        }

        # Handle OPTIONS without touching upstream
        if ($request_method = OPTIONS) {
            return 204;
        }

        # --- Method allow-list
        limit_except GET POST PUT PATCH DELETE {
            return 405;
        }

        # --- API key guard (simple)
        if ($api_key_ok = 0) {
            return 401;
        }

        # --- (Enable one of the JWT options above to enforce bearer tokens)
        # auth_jwt "crapi";
        # auth_jwt_key_request /_jwks;     # for Option A
        # auth_jwt_key_file /etc/nginx/jwt/jwks.json;  # for Option B

        # --- Proxy settings
        proxy_pass http://httpbin_backend;

        proxy_set_header Host $host;
        proxy_set_header X-Request-ID $request_id;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Custom JSON body for rate-limit rejections (HTTP 429)
    error_page 429 = @rate_limited;
    location @rate_limited {
        add_header Content-Type application/json;
        return 429 '{"error":"rate_limited","detail":"Too many requests. Limit is 1 request per second."}';
    }
}
